#!/usr/bin/python3
"""
Juniper Junos Salt pillar generator
Copyright (C) 2023 SUSE LLC

Originally contractually developed for SUSE by DEVOQ TECHNOLOGY I.K.E.:
Konstantinos Kanavidis, Adam Pavlidis and Dimitrios Kalogeras

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import argparse
import json
import logging
import os
import pprint
import sys

from yaml import safe_load
import yaml

logger = logging.getLogger(__name__)


parser = argparse.ArgumentParser(description="compile_junos - a script that generates pillar data for juniper!")

parser.add_argument(
    '--log',
    type=str,
    help='Type of operation.',
    default='info',
    choices=[
        'debug',
        'info',
        'warn',
        'error',
        'critical'
    ]
)

log_choices_converter = {
    'debug': logging.DEBUG,
    'info': logging.INFO,
    'warn': logging.WARN,
    'error': logging.ERROR,
    'critical': logging.CRITICAL
}
OUTPUT_PATH = '/srv/coderepo/'

parser.add_argument('domain', type=str, help='select either internal or dmz mode', choices=['dmz', 'internal'])

args = parser.parse_args()

param_dict = {
    'dmz': {
        'USER_CONF': '/srv/data/dmz_sw.yaml',
        'BACKBONE_CONF': '/srv/coderepo/dmz_bb.yaml'
    },
    'internal': {
        'USER_CONF': '/srv/data/internal_sw.yaml',
        'BACKBONE_CONF': '/srv/coderepo/internal_bb.yaml'
    },
}

def compute_switch_pillar_data(all_pillars, switch_sot):

    port_group_data = switch_sot.get('port_groups', {})

    global_ignore_ports = switch_sot.get('global_ignore_ports', [])

    per_switch_ignore_ports = switch_sot.get('per_switch_ignore_ports', {})

    logger.debug(all_pillars)
    logger.debug(f'port_group_data {port_group_data}')
    core = [dev.get('id') for dev in switch_sot.get('switches', [])
            if dev.get('type') == 'switch' and dev.get('role') == 'core']
    aggregation = [dev.get('id') for dev in switch_sot.get('switches', [])
                   if dev.get('type') == 'switch' and dev.get('role') == 'aggregation']
    access = [dev.get('id') for dev in switch_sot.get('switches', [])
              if dev.get('type') == 'switch' and dev.get('role') == 'access']

    logger.debug(f'Core switches {core}')
    logger.debug(f'Access switches {access}')
    logger.debug(f'All PILLAR DATA {all_pillars}')
    logger.debug(f'Switching SOT {switch_sot}')

    switch_pillar = {
        adev: {
            'vlans': [],
            'vlan_set': set(),
            'lacp': {},
            'ports': {},
            'ignore_ports': list(global_ignore_ports)
        } for adev in access + aggregation + core
    }

    # update ignore ports
    for dev, dev_pillar in switch_pillar.items():
        try:
            per_switch_ignore = per_switch_ignore_ports[dev]

        except KeyError:
            per_switch_ignore = []

        switch_pillar[dev]['ignore_ports'] += per_switch_ignore
        switch_pillar[dev]['ignore_ports'] = list(set(switch_pillar[dev]['ignore_ports']))

    # vlans
    vlans = switch_sot.get('vlans', [])
    for vlan in vlans:
        vl_id = vlan.get('id')
        vl_name = vlan.get('name')
        vl_descr = vlan.get('description')

        logger.debug(f'Processing VLAN ID: {vl_id}, VLAN NAME: {vl_name}, VLAN DESCRIPTION: {vl_descr}')

        for group in vlan.get('groups', []):
            # populate vlan list

            logger.debug(f' Adding GROUP: {group} to VLAN LIST.')
            logger.debug(f' port_group_data: {port_group_data}')

            try:
                for grp_member, grp_data in port_group_data[group].items():
                    description = grp_data.get('description', 'portgroup managed by automation')
                    member_ports = grp_data.get('members', [])

                    if vl_id in switch_pillar[grp_member]['vlan_set']:
                        logger.debug(f'VLAN {vl_id} already exists.')

                    else:
                        switch_pillar[grp_member]['vlan_set'] = switch_pillar[grp_member]['vlan_set'].union({vl_id})
                        switch_pillar[grp_member]['vlans'].append({'id': vl_id, 'name': vl_name, 'description': vl_descr})

                    # populate port_list
                    for member_port in member_ports:
                        try:
                            iface = member_port['iface']

                        except KeyError:
                            logger.error(f'key "iface" not specified. skipping entry {member_port}')
                            continue

                        if iface in switch_pillar[grp_member]['ignore_ports']:
                            logger.error(f'Something is seriously wrong. Check your port_group members & ignored ports.'
                                         f'{grp_member}, {iface} DO NOT RUN ANY SWITCHING AUTOMATION')
                            sys.exit(1)

                        iface_descr = member_port.get('description', description)

                        try:
                            if vl_id not in switch_pillar[grp_member]['ports'][iface]['tagged']:
                                switch_pillar[grp_member]['ports'][iface]['tagged'].append(vl_id)

                            if 'description' not in switch_pillar[grp_member]['ports'][iface]:
                                switch_pillar[grp_member]['ports'][iface]['description'] = iface_descr

                        except KeyError:
                            switch_pillar[grp_member]['ports'][iface] = {
                                'iface': iface,
                                'untagged': None,
                                'tagged': [vl_id],
                                'description': iface_descr
                            }

            except KeyError as error:
                logger.error(error, exc_info=True)
                logger.error(f'{group} is used in the vlan definition, but attributes are NOT DEFINED!')

    # CALCULATE BACKBONE LACPs
    sw_lacp_bb = switch_sot.get('lacp_bb', {})

    sw_lacp_inverted_dict = {}

    for dev, lacps in sw_lacp_bb.items():
        for lacp in lacps:

            lacp_id = lacp.get('lacp_id')

            if lacp_id in switch_pillar[dev]['ignore_ports']:
                logger.error(f'Something is seriously wrong. Check your lacp_bb definitions & ignored ports. '
                             f'{dev}, {lacp_id}. DO NOT RUN ANY SWITCHING AUTOMATION')
                sys.exit(1)

            for member in lacp.get('members', []):
                iface = member.get('iface')
                logger.debug('Computing lacp_inverted_dict: %s', iface)

                if iface in switch_pillar[dev]['ignore_ports']:
                    logger.error(f'Something is seriously wrong. Check your lacp_bb MEMBERS & ignored ports. '
                                 f'{dev}, {lacp_id}, {iface}. DO NOT RUN ANY SWITCHING AUTOMATION')
                    sys.exit(1)

                try:
                    sw_lacp_inverted_dict[dev][iface] = {
                        'parent': lacp_id,
                        'description': member.get(
                            'description',
                            f'member-of-lag-{lacp_id}'
                        )
                    }

                except KeyError:
                    sw_lacp_inverted_dict[dev] = {
                        iface: {
                            'parent': lacp_id,
                            'description': member.get(
                                'description',
                                f'member-of-lag-{lacp_id}'
                            )
                        }
                    }

    logger.debug("sw_lacp_inverted_dict: %s", json.dumps(sw_lacp_inverted_dict))

    # LACP ports slave ports should not be present in ports dict
    sw_lacp = switch_sot.get('lacp', {})

    for dev, aelist in sw_lacp.items():
        for aeif in aelist:

            lacp_id = aeif.get('lacp_id')

            if lacp_id in [elem.get('lacp_id') for elem in sw_lacp_bb.get(dev, [])]:
                logger.error(f'You are re-declaring an AE interface used in backbone links. {dev}, {aeif} '
                             'Ignoring...')

                continue

            if lacp_id in switch_pillar[dev]['ignore_ports']:
                logger.error(f'You are messing with an interface that is to be IGNORED. Check your lacp_id definition. '
                             f'{dev}, {lacp_id}.'
                             'Ignoring... ')
                continue

            for member in aeif.get('members'):
                iface = member.get('iface', None)

                if not iface:
                    continue

                elif iface in sw_lacp_inverted_dict.get(dev, {}):
                    logger.error(f'You are trying to create an AE with interface used in backbone AE. {dev}, {iface} '
                                 'Ignoring...')
                    continue

                else:

                    if iface in switch_pillar[dev]['ignore_ports']:
                        logger.error(f'You are messing with an interface that is to be IGNORED. '
                                     f'Check your LACP members.'
                                     f'{dev}, {lacp_id}, {iface}. '
                                     'Ignoring...')
                        continue

                    try:
                        sw_lacp_inverted_dict[dev][iface] = {
                            'parent': lacp_id,
                            'description': member.get(
                                'description',
                                f'member-of-lag-{lacp_id}'
                            )
                        }

                    except KeyError:
                        sw_lacp_inverted_dict[dev] = {
                            iface: {
                                'parent': lacp_id,
                                'description': member.get(
                                    'description',
                                    f'member-of-lag-{lacp_id}'
                                )
                            }
                        }

    for dev, port_dict in sw_lacp_inverted_dict.items():
        logger.debug(f'lacp: {dev}, {port_dict}')

        ports_to_remove = []

        for member in port_dict.keys():
            if dev in switch_pillar and member in switch_pillar[dev]['ports']:
                logger.error(f'You are trying to manipulate a backbone link {dev}, {member} '
                             'Ignoring...')
                ports_to_remove.append(member)

        for port_remove in ports_to_remove:
            port_dict.pop(port_remove)

        switch_pillar[dev]['lacp'] = port_dict

    sw_ports = switch_sot.get('ports', {})
    for dev, port_dict in sw_ports.items():
        logger.debug(f'ports: {dev}, {port_dict}')
        for member in port_dict.keys():
            if dev in switch_pillar and member in switch_pillar[dev]['ports']:
                logger.error(f'You are messing with a declared backbone link. {dev}, {member} '
                             'Ignoring...')

                continue
            elif dev in switch_pillar and member in switch_pillar[dev]['lacp']:
                logger.error(f'You are messing with a declared lacp slave phyport. {dev}, {member} '
                             'Ignoring...')

                continue

            elif member in switch_pillar[dev]['ignore_ports']:
                logger.error(f'You are messing with the switching configuration of an interface that is to be IGNORED. '
                             f'{dev}, {member}. '
                             'Ignoring...')
                continue

            else:
                switch_pillar[dev]['ports'][member] = dict(port_dict[member])
    # elements of ports dict should not be present in vlan group ports dict neither in LACP

    # update ae ports with pillar data

    for dev, lacp_list in sw_lacp.items():
        for lacp_elem in lacp_list:
            iface = lacp_elem.get('lacp_id')

            if iface in [elem.get('lacp_id') for elem in sw_lacp_bb.get(dev, [])]:
                continue

            lacp_options = dict(lacp_elem.get('lacp_options', {}))

            ### SET DEFAULTS

            # lacp_options.setdefault('mode', 'active')
            # lacp_options.setdefault('system-id', '01:01:01:01:01:01')
            # lacp_options.setdefault('admin-key', '3')

            mclag_options = dict(lacp_elem.get('mclag_options', {}))

            ### SET DEFAULTS

            mclag_options.setdefault('mc-ae-id', '1')
            mclag_options.setdefault('redundancy-group', '1')
            # mclag_options.setdefault('init-delay-time', '240')

            if dev.endswith('1'):
                mclag_options.setdefault('chassis-id', '0')
                mclag_options.setdefault('status-control', 'active')

            elif dev.endswith('2'):
                mclag_options.setdefault('chassis-id', '1')
                mclag_options.setdefault('status-control', 'passive')

            else:
                logger.debug(f'Cannot auto-discover chassis-id, status-control. For {dev}, {iface}, {mclag_options}')

            try:
                switch_pillar[dev]['ports'][iface]['lacp_options'] = lacp_options
                switch_pillar[dev]['ports'][iface]['mclag_options'] = mclag_options

            except KeyError as error:
                logger.warning(f'You have defined a LACP iface without switching configuration. {dev}, {iface} '
                               f'Setting description and options only')

                switch_pillar[dev]['ports'][iface] = {
                    'description': lacp_elem.get('description', f'{iface}-managed by automation'),
                    'lacp_options': lacp_options,
                    'mclag_options': mclag_options
                }

    # update ae backbone ports with pillar data
    for dev, lacp_list in sw_lacp_bb.items():
        for lacp_elem in lacp_list:
            iface = lacp_elem.get('lacp_id')

            lacp_options = dict(lacp_elem.get('lacp_options', {}))

            ### SET DEFAULTS

            # lacp_options.setdefault('mode', 'active')
            # lacp_options.setdefault('system-id', '01:01:01:01:01:01')
            # lacp_options.setdefault('admin-key', '3')

            mclag_options = dict(lacp_elem.get('mclag_options', {}))

            ### SET DEFAULTS

            mclag_options.setdefault('mc-ae-id', '1')
            mclag_options.setdefault('redundancy-group', '1')
            # mclag_options.setdefault('init-delay-time', '240')

            if dev.endswith('1'):
                mclag_options.setdefault('chassis-id', '0')
                mclag_options.setdefault('status-control', 'active')

            elif dev.endswith('2'):
                mclag_options.setdefault('chassis-id', '1')
                mclag_options.setdefault('status-control', 'passive')

            else:
                logger.debug(f'Cannot auto-discover chassis-id, status-control. For {dev}, {iface}, {mclag_options}')

            try:

                description = lacp_elem.get('description', None)

                if description:
                    switch_pillar[dev]['ports'][iface]['description'] = description

                switch_pillar[dev]['ports'][iface]['lacp_options'] = lacp_options
                switch_pillar[dev]['ports'][iface]['mclag_options'] = mclag_options

            except KeyError as error:
                logger.warning(f'You have defined a LACP iface without switching configuration. {dev}, {iface} '
                               f'Setting description and options only')

                switch_pillar[dev]['ports'][iface] = {
                    'description': lacp_elem.get('description', f'{iface}-managed by automation'),
                    'lacp_options': lacp_options,
                    'mclag_options': mclag_options
                }

    ntp_servers = switch_sot.get('ntp_servers')
    syslog_servers = switch_sot.get('syslog_servers')
    snmp = switch_sot.get('snmp')

    # sanitize stuff
    for dev, data in switch_pillar.items():
        data.pop('vlan_set')
        if 'dev' in all_pillars:
            all_pillars[dev].update(switch_pillar[dev])
        else:
            all_pillars[dev] = dict(data)

        all_pillars[dev]['ntp_servers'] = ntp_servers
        all_pillars[dev]['syslog_servers'] = syslog_servers
        all_pillars[dev]['snmp'] = snmp

    return all_pillars


def main():
    domain= getattr(args, 'domain')


    # create switching pillars
    user_sot_file = param_dict[domain]['USER_CONF']
    backbone_sot_file = param_dict[domain]['BACKBONE_CONF']

    try:
        with open(user_sot_file) as f:
            switch_sot = safe_load(f)

        with open(backbone_sot_file) as f:
            backbone_sot = safe_load(f)

        switch_sot.update(backbone_sot)

        logger.debug(json.dumps(switch_sot, indent=4))
        all_pillars = compute_switch_pillar_data(
            {},
            switch_sot)

    except FileNotFoundError:
        logger.warning(f'{user_sot_file} not found. Skipping pillar generation for switching.')
        all_pillars = {}

    for dev, data in all_pillars.items():
        with open(f'{OUTPUT_PATH}/yamls_{domain}/{dev}_data.sls', 'w') as f:
            yaml.dump(data, f)

    logger.debug(f'All Pillar_data after switching data calculation.\n{json.dumps(all_pillars, indent=4)}')


if __name__ == '__main__':
    logger = logging.getLogger()
    logger.setLevel(log_choices_converter[getattr(args, 'log')])

    logger.addHandler(logging.StreamHandler(sys.stdout))

    logger.debug(args)
    main()
